// Project Management Application Schema
// A comprehensive project management system with advanced iteration cycles,
// impediment tracking, and multi-role user management
//
// Key Features:
// - Dual role system (Customer/Contributor) with hierarchical permissions
// - Advanced project iteration cycles with segment-based workflow
// - AI-powered impediment matching and solution tracking
// - Full-text search capabilities on tasks and projects
// - Complex project state management with multiple workflow paths

generator client {
  provider = "prisma-client-js"
  output   = "../../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Native PostgreSQL enums for better performance and type safety
enum MainRoleTitle {
  CUSTOMER
  CONTRIBUTOR
}

enum ProjectStateType {
  DRAFT
  INQUIRY_PENDING
  ACCEPTED
  REJECTED
  PLANNING
  INTAKE
  IN_PROGRESS
  REVISION
  COMPLETED
  CANCELLED
  ON_HOLD
}

enum TaskStateType {
  TODO
  IN_PROGRESS
  REVIEW
  BLOCKED
  DONE
  CANCELLED
}

enum PriorityLevel {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

enum ImpedimentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CANCELLED
}

// Permission system for granular access control
// App constraint: Permissions should be cached and validated on each request
model Permission {
  id          Int              @id @default(autoincrement())
  name        String           @unique // e.g., "task.create", "project.delete", "user.manage"
  description String?
  category    String // e.g., "task", "project", "user", "admin"
  roles       RolePermission[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([category])
}

// Junction table for role-permission many-to-many relationship
model RolePermission {
  id           Int        @id @default(autoincrement())
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

// Hierarchical role system with echelons (Junior, Mid, Senior)
// App constraint: Role hierarchy must be validated to prevent circular references
model Echelon {
  id          Int      @id @default(autoincrement())
  title       String   @unique // Junior, Mid, Senior
  description String // Detailed rights and responsibilities
  orderLevel  Int      @unique // 1=Junior, 2=Mid, 3=Senior for hierarchy
  roles       Role[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([orderLevel])
}

// Complex role system supporting both main roles and sub-roles
// App constraint: mainRoleType self-reference must prevent infinite loops
model Role {
  id              Int              @id @default(autoincrement())
  isMainRole      Boolean          @default(false)
  mainRoleTitle   MainRoleTitle?
  parentRoleId    Int? // Self-reference for role hierarchy
  parentRole      Role?            @relation("RoleHierarchy", fields: [parentRoleId], references: [id])
  subRoles        Role[]           @relation("RoleHierarchy")
  title           String
  description     String?
  echelonId       Int
  echelon         Echelon          @relation(fields: [echelonId], references: [id])
  rolePermissions RolePermission[]
  users           UserRole[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([isMainRole])
  @@index([mainRoleTitle])
  @@index([echelonId])
}
// Migration note: Add CHECK constraint to ensure mainRoleTitle is only set when isMainRole is true

// User system with multi-role support
// App constraint: Email validation, password hashing, token expiration management
model User {
  id                  Int                  @id @default(autoincrement())
  email               String               @unique
  forename            String?
  surname             String?
  username            String?              @unique
  password            String // App: Hash with bcrypt or Argon2id
  isActive            Boolean              @default(true)
  roles               UserRole[]
  tasks               UserTask[] // Many-to-many with tasks
  activeTasks         Task[]               @relation("ActiveUserOnTask")
  createdProjects     Project[]            @relation("ProjectCreator")
  activeProjects      Project[]            @relation("ActiveUserOnProject")
  // Segment role memberships via explicit junction tables
  segmentStakeholders SegmentStakeholder[] // should be 'segmentStakeholderIn'
  segmentResponsibles SegmentResponsible[]
  segmentAttendees    SegmentAttendee[]
  segmentContributors SegmentContributor[]
  impedimentAssignees Impediment[]         @relation("ImpedimentAssignee")
  solutionAuthors     Solution[]           @relation("SolutionAuthor")
  sessions            Session[]
  verificationTokens  VerificationToken[]
  passwordResetTokens PasswordResetToken[]
  auditLogs           AuditLog[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt

  @@index([email])
  @@index([username])
  @@index([isActive])
}

// Junction table for user-role many-to-many relationship
model UserRole {
  id         Int      @id @default(autoincrement())
  userId     Int
  roleId     Int
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  assignedAt DateTime @default(now())

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

// Flexible tagging system with color coding
// App constraint: Validate HEX color format (#RRGGBB)
model Tag {
  id        String        @id @default(cuid())
  title     String        @unique
  color     String // HEX color format
  tasks     TaskTag[]
  projects  ProjectTag[]
  deadlines DeadlineTag[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@index([title])
}
// Migration note: Add CHECK constraint for HEX color validation: color ~ '^#[0-9A-Fa-f]{6}$'

// Project state management
// App constraint: State transitions should follow defined workflow rules
model ProjectState {
  id          String           @id @default(cuid())
  type        ProjectStateType @default(DRAFT)
  title       String
  description String?
  color       String // HEX color for UI
  orderNo     Int // For workflow ordering
  isInitial   Boolean          @default(false)
  isFinal     Boolean          @default(false)
  projects    Project[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@unique([orderNo])
  @@index([type])
  @@index([orderNo])
}
// Migration note: Add CHECK constraint for HEX color validation

// Task state management
// App constraint: State transitions should follow Kanban workflow
model TaskState {
  id          String        @id @default(cuid())
  type        TaskStateType @default(TODO)
  title       String
  description String?
  color       String // HEX color for UI
  orderNo     Int // For Kanban ordering
  isInitial   Boolean       @default(false)
  isFinal     Boolean       @default(false)
  tasks       Task[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@unique([orderNo])
  @@index([type])
  @@index([orderNo])
}
// Migration note: Add CHECK constraint for HEX color validation

// Priority system with ordering
// App constraint: Priority levels should be consistent across the application
model Priority {
  id          String        @id @default(cuid())
  level       PriorityLevel
  title       String
  description String?
  orderNo     Int           @unique // 1=Critical, 2=High, 3=Medium, 4=Low
  color       String // HEX color for UI
  deadlines   Deadline[]
  tasks       Task[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@unique([level])
  @@index([orderNo])
  @@index([level])
}
// Migration note: Add CHECK constraint for HEX color validation

// Deadline management with priority and tagging
// App constraint: Validate dueDate is in the future when creating
model Deadline {
  id          String        @id @default(cuid())
  title       String
  description String?
  dueDate     DateTime
  priorityId  String
  priority    Priority      @relation(fields: [priorityId], references: [id])
  projectId   String?
  project     Project?      @relation(fields: [projectId], references: [id])
  tags        DeadlineTag[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([dueDate])
  @@index([priorityId])
  @@index([projectId])
}

// Junction table for deadline-tag relationship
model DeadlineTag {
  id         Int      @id @default(autoincrement())
  deadlineId String
  tagId      String
  deadline   Deadline @relation(fields: [deadlineId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([deadlineId, tagId])
  @@index([deadlineId])
  @@index([tagId])
}

// Solution library for impediments
// App constraint: Solutions should be searchable and categorizable
model Solution {
  id                Int                @id @default(autoincrement())
  title             String
  explanation       String // Full-text searchable
  link              String? // Optional reference link
  authorId          Int?
  author            User?              @relation("SolutionAuthor", fields: [authorId], references: [id])
  impediments       Impediment[]
  impedimentMedians ImpedimentMedian[]
  category          String? // For categorization
  effectiveness     Float?             @default(0.0) // Success rate 0.0-1.0
  usageCount        Int                @default(0) // Track solution popularity
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([category])
  @@index([effectiveness])
}
// Migration note: Add GIN index for full-text search on explanation field
// CREATE INDEX CONCURRENTLY idx_solution_explanation_fulltext ON "Solution" USING gin(to_tsvector('english', explanation));

// Individual impediment tracking
// App constraint: AI-powered similar impediment detection for merging
model Impediment {
  id              Int               @id @default(autoincrement())
  title           String
  description     String? // Full-text searchable
  status          ImpedimentStatus  @default(OPEN)
  estimatedHours  Int? // Original estimate in hours
  actualHours     Int? // Actual time spent
  isDone          Boolean           @default(false)
  solutionId      Int?
  solution        Solution?         @relation(fields: [solutionId], references: [id])
  assigneeId      Int?
  assignee        User?             @relation("ImpedimentAssignee", fields: [assigneeId], references: [id])
  taskId          String?
  task            Task?             @relation(fields: [taskId], references: [id])
  // AI matching fields
  similarityScore Float? // For AI-powered matching
  mergedIntoId    Int? // Reference to ImpedimentMedian if merged
  mergedInto      ImpedimentMedian? @relation(fields: [mergedIntoId], references: [id])
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([status])
  @@index([assigneeId])
  @@index([taskId])
  @@index([mergedIntoId])
}
// Migration note: Add GIN index for full-text search on title and description
// CREATE INDEX CONCURRENTLY idx_impediment_fulltext ON "Impediment" USING gin(to_tsvector('english', title || ' ' || COALESCE(description, '')));

// Merged impediment tracking for AI-powered analysis
// App constraint: AI system should analyze patterns and suggest solutions
model ImpedimentMedian {
  id                Int          @id @default(autoincrement())
  title             String
  description       String?
  hasSolution       Boolean      @default(false)
  solutionId        Int?
  solution          Solution?    @relation(fields: [solutionId], references: [id])
  averageHours      Float? // Average time to resolve
  occurrenceCount   Int          @default(1) // How many impediments merged
  mergedImpediments Impediment[]
  confidenceScore   Float? // AI confidence in the merge
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  @@index([hasSolution])
  @@index([occurrenceCount])
}
// Migration note: Add GIN index for full-text search
// CREATE INDEX CONCURRENTLY idx_impediment_median_fulltext ON "ImpedimentMedian" USING gin(to_tsvector('english', title || ' ' || COALESCE(description, '')));

// Core task management
// App constraint: Complex business logic for task assignment and progress tracking
model Task {
  id                    String              @id @default(cuid())
  title                 String
  description           String // Full-text searchable
  isDone                Boolean             @default(false)
  taskStateId           String
  taskState             TaskState           @relation(fields: [taskStateId], references: [id])
  priorityId            String?
  priority              Priority?           @relation(fields: [priorityId], references: [id])
  users                 UserTask[] // Many-to-many with users
  activeUserId          Int?
  activeUser            User?               @relation("ActiveUserOnTask", fields: [activeUserId], references: [id])
  tags                  TaskTag[]
  estimatedHours        Int? // Time estimate in hours
  actualHours           Int? // Time actually spent
  impediments           Impediment[]
  hasSegmentGroupCircle Boolean             @default(false)
  segmentGroupCircleId  Int?
  segmentGroupCircle    SegmentGroupCircle? @relation(fields: [segmentGroupCircleId], references: [id])
  projectId             String?
  project               Project?            @relation(fields: [projectId], references: [id])
  parentTaskId          String? // For sub-tasks
  parentTask            Task?               @relation("TaskHierarchy", fields: [parentTaskId], references: [id])
  subTasks              Task[]              @relation("TaskHierarchy")
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  dueDate               DateTime?
  startDate             DateTime?

  @@index([taskStateId])
  @@index([activeUserId])
  @@index([projectId])
  @@index([parentTaskId])
  @@index([isDone])
  @@index([dueDate])
}
// Migration note: Add GIN index for full-text search on title and description
// CREATE INDEX CONCURRENTLY idx_task_fulltext ON "Task" USING gin(to_tsvector('english', title || ' ' || description));

// Junction table for task-user many-to-many relationship
model UserTask {
  id         Int      @id @default(autoincrement())
  userId     Int
  taskId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  task       Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  role       String? // Role in this specific task (assignee, reviewer, etc.)
  assignedAt DateTime @default(now())

  @@unique([userId, taskId])
  @@index([userId])
  @@index([taskId])
}

// Junction table for task-tag relationship
model TaskTag {
  id        Int      @id @default(autoincrement())
  taskId    String
  tagId     String
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([taskId, tagId])
  @@index([taskId])
  @@index([tagId])
}

// Complex iteration segment system
// App constraint: Sophisticated workflow engine with predefined and custom segments
model IterationSegment {
  id                   Int                  @id @default(autoincrement())
  segmentNo            Int // Order within the circle
  // segmentType removed: segment behavior defined by title/description and app logic
  title                String
  description          String?
  stakeholders         SegmentStakeholder[]
  responsibles         SegmentResponsible[]
  attendees            SegmentAttendee[]
  contributors         SegmentContributor[]
  startSchedule        DateTime?
  endSchedule          DateTime?
  dueDate              DateTime?
  dropDate             DateTime? // Deadline for dropping the segment
  actualStartDate      DateTime?
  actualEndDate        DateTime?
  iterationCount       Int                  @default(1) // How many times this segment was iterated
  completedIterations  Int                  @default(0) // How many iterations completed
  isComplete           Boolean              @default(false)
  estimatedCost        Decimal?             @db.Money
  actualCost           Decimal?             @db.Money
  estimatedHours       Int?
  actualHours          Int?
  segmentGroupCircleId Int
  segmentGroupCircle   SegmentGroupCircle   @relation(fields: [segmentGroupCircleId], references: [id], onDelete: Cascade)
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  currentForProjects   Project[]

  @@index([segmentGroupCircleId])
  @@index([segmentNo])
  @@index([isComplete])
  @@index([dueDate])
}

// Advanced segment group circle system for project workflow management
// App constraint: Complex workflow engine with multiple circle types and transitions
model SegmentGroupCircle {
  id                        Int                  @id @default(autoincrement())
  orderNo                   Int // Order of execution
  title                     String
  description               String?
  segments                  IterationSegment[]
  isProjectManagementCircle Boolean              @default(false)
  isInternal                Boolean              @default(false)
  isFirst                   Boolean              @default(false)
  isActive                  Boolean              @default(false)
  isComplete                Boolean              @default(false)
  maxIterations             Int                  @default(1) // Maximum allowed iterations
  currentIteration          Int                  @default(1)
  tasks                     Task[]
  projects                  Project[]
  parentCircleId            Int? // For nested circles
  parentCircle              SegmentGroupCircle?  @relation("CircleHierarchy", fields: [parentCircleId], references: [id])
  childCircles              SegmentGroupCircle[] @relation("CircleHierarchy")
  estimatedDuration         Int? // In hours
  actualDuration            Int? // In hours
  createdAt                 DateTime             @default(now())
  updatedAt                 DateTime             @updatedAt

  @@index([orderNo])
  @@index([isProjectManagementCircle])
  @@index([isInternal])
  @@index([isFirst])
  @@index([isActive])
  @@index([parentCircleId])
}
// Migration note: Add CHECK constraint to ensure isInternal and isProjectManagementCircle are not both true

// Main project management entity
// App constraint: Complex project lifecycle management with multiple workflow paths
model Project {
  id                     String              @id @default(cuid())
  title                  String
  description            String // Full-text searchable
  deadlines              Deadline[]
  isDone                 Boolean             @default(false)
  currentIterationNumber Int                 @default(1)
  iterationWarnAt        Int                 @default(3) // Warn when approaching this iteration
  maxIterations          Int? // Maximum allowed iterations
  currentSegmentId       Int? // Current active segment
  currentSegment         IterationSegment?   @relation(fields: [currentSegmentId], references: [id])
  projectStateId         String
  projectState           ProjectState        @relation(fields: [projectStateId], references: [id])
  segmentGroupCircleId   Int?
  segmentGroupCircle     SegmentGroupCircle? @relation(fields: [segmentGroupCircleId], references: [id])
  creators               User[]              @relation("ProjectCreator")
  activeUserId           Int?
  activeUser             User?               @relation("ActiveUserOnProject", fields: [activeUserId], references: [id])
  tags                   ProjectTag[]
  tasks                  Task[]
  estimatedBudget        Decimal?            @db.Money
  actualCost             Decimal?            @db.Money
  estimatedHours         Int?
  actualHours            Int?
  startDate              DateTime?
  endDate                DateTime?
  actualStartDate        DateTime?
  actualEndDate          DateTime?
  priority               String? // Project priority level
  riskLevel              String? // Risk assessment
  createdAt              DateTime            @default(now())
  updatedAt              DateTime            @updatedAt

  @@index([projectStateId])
  @@index([activeUserId])
  @@index([segmentGroupCircleId])
  @@index([isDone])
  @@index([currentIterationNumber])
  @@index([startDate])
  @@index([endDate])
}
// Migration note: Add GIN index for full-text search on title and description
// CREATE INDEX CONCURRENTLY idx_project_fulltext ON "Project" USING gin(to_tsvector('english', title || ' ' || description));

// Junction table for project-tag relationship
model ProjectTag {
  id        Int      @id @default(autoincrement())
  projectId String
  tagId     String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([projectId, tagId])
  @@index([projectId])
  @@index([tagId])
}

// Audit log for tracking changes (optional but recommended)
// App constraint: Implement automatic logging for sensitive operations
model AuditLog {
  id        Int      @id @default(autoincrement())
  userId    Int?
  user      User?    @relation(fields: [userId], references: [id])
  action    String // CREATE, UPDATE, DELETE
  tableName String // Which table was affected
  recordId  String // ID of the affected record
  oldValues Json? // Previous values (for updates/deletes)
  newValues Json? // New values (for creates/updates)
  ipAddress String?
  userAgent String?
  timestamp DateTime @default(now())

  @@index([userId])
  @@index([tableName])
  @@index([recordId])
  @@index([timestamp])
}
// Migration note: Consider partitioning this table by timestamp for better performance

// System settings for application configuration
model SystemSetting {
  id          Int      @id @default(autoincrement())
  key         String   @unique
  value       String
  description String?
  category    String? // Group settings by category
  isPublic    Boolean  @default(false) // Whether setting is visible to non-admins
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@index([isPublic])
}

// Explicit segment role junction tables
model SegmentStakeholder {
  id                 Int              @id @default(autoincrement())
  userId             Int
  iterationSegmentId Int
  user               User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  segment            IterationSegment @relation(fields: [iterationSegmentId], references: [id], onDelete: Cascade)
  assignedAt         DateTime         @default(now())

  @@unique([userId, iterationSegmentId])
  @@index([userId])
  @@index([iterationSegmentId])
}

model SegmentResponsible {
  id                 Int              @id @default(autoincrement())
  userId             Int
  iterationSegmentId Int
  user               User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  segment            IterationSegment @relation(fields: [iterationSegmentId], references: [id], onDelete: Cascade)
  assignedAt         DateTime         @default(now())

  @@unique([userId, iterationSegmentId])
  @@index([userId])
  @@index([iterationSegmentId])
}

model SegmentAttendee {
  id                 Int              @id @default(autoincrement())
  userId             Int
  iterationSegmentId Int
  user               User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  segment            IterationSegment @relation(fields: [iterationSegmentId], references: [id], onDelete: Cascade)

  @@unique([userId, iterationSegmentId])
  @@index([userId])
  @@index([iterationSegmentId])
}

model SegmentContributor {
  id                 Int              @id @default(autoincrement())
  userId             Int
  iterationSegmentId Int
  user               User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  segment            IterationSegment @relation(fields: [iterationSegmentId], references: [id], onDelete: Cascade)

  @@unique([userId, iterationSegmentId])
  @@index([userId])
  @@index([iterationSegmentId])
}

// Auth: sessions and tokens (store only hashed tokens)
model Session {
  id         String    @id @default(cuid())
  userId     Int
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash  String    @unique
  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  lastUsedAt DateTime?
  userAgent  String?
  ip         String?
  revokedAt  DateTime?

  @@index([userId])
  @@index([expiresAt])
}

model VerificationToken {
  id        String   @id @default(cuid())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String   @unique
  type      String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}
